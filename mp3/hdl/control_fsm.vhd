-- VHDL Entity ece411.Control.interface
--
-- Created:
--          by - ravi7.ews (linux-a3.ews.illinois.edu)
--          at - 21:46:31 03/09/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;

ENTITY Control IS
   PORT( 
      CheckN        : IN     std_logic;
      CheckP        : IN     std_logic;
      CheckZ        : IN     std_logic;
      MRESP_H       : IN     std_logic;
      Opcode        : IN     LC3b_opcode;
      Parity        : IN     std_logic;
      RESET_L       : IN     std_logic;
      START_H       : IN     std_logic;
      bit11         : IN     std_logic;
      bit4          : IN     std_logic;
      bit5          : IN     std_logic;
      clk           : IN     std_logic;
      n             : IN     std_logic;
      p             : IN     std_logic;
      z             : IN     std_logic;
      ALUMuxSel     : OUT    std_logic_vector (1 DOWNTO 0);
      ALUop         : OUT    LC3b_aluop;
      DestnSel      : OUT    std_logic;
      LoadIR        : OUT    std_logic;
      LoadMAR       : OUT    std_logic;
      LoadMDR       : OUT    std_logic;
      LoadNZP       : OUT    std_logic;
      LoadPC        : OUT    std_logic;
      MARMuxSel     : OUT    std_logic_vector (1 DOWNTO 0);
      MDRMuxSel     : OUT    std_logic;
      MREAD_L       : OUT    std_logic;
      MWRITEH_L     : OUT    std_logic;
      MWRITEL_L     : OUT    std_logic;
      PCMuxSel      : OUT    std_logic_vector (1 DOWNTO 0);
      RFAorMDR      : OUT    std_logic;
      RFMuxSel      : OUT    std_logic_vector (2 DOWNTO 0);
      RegWrite      : OUT    std_logic;
      SextorADJ     : OUT    std_logic;
      ShiftSelector : OUT    std_logic_vector (1 DOWNTO 0);
      StoreSR       : OUT    std_logic
   );

-- Declarations

END Control ;

--
-- VHDL Architecture ece411.Control.fsm
--
-- Created:
--          by - ravi7.ews (linux-a3.ews.illinois.edu)
--          at - 21:46:31 03/09/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;
 
ARCHITECTURE fsm OF Control IS

   TYPE STATE_TYPE IS (
      Reset,
      Decode,
      BR1,
      BR2,
      L_NOT,
      IF1,
      IF2,
      IF3,
      CalcADDR,
      LD1,
      ST1,
      ST2,
      LD2,
      JMP,
      LEA,
      ADD_R,
      ADD_IM,
      And_R,
      And_Imm,
      JSR1,
      JSRR1,
      TRAP1,
      TRAP2,
      Trap2_3,
      CalcAddress,
      CalcAddress2,
      CalcAddress3,
      LDI1,
      STI1,
      STI2,
      LDI2,
      SHF,
      CalcAdd,
      STB0,
      EnterMDR,
      Check4Byte,
      HighB,
      LowB,
      STB_1_1,
      STB_1_2,
      MEM_LB,
      MEM_HB
   );
 
   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk,
      RESET_L
   )
   -----------------------------------------------------------------
   BEGIN
      IF (RESET_L = '0') THEN
         current_state <= Reset;
      ELSIF (clk'EVENT AND clk = '1') THEN
         current_state <= next_state;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      CheckN,
      CheckP,
      CheckZ,
      MRESP_H,
      Opcode,
      Parity,
      START_H,
      bit11,
      bit5,
      current_state,
      n,
      p,
      z
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN Reset => 
            IF (START_H='1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= Reset;
            END IF;
         WHEN Decode => 
            IF (Opcode=op_br) THEN 
               next_state <= BR1;
            ELSIF ((Opcode=op_ldr) OR (Opcode=op_str)) THEN 
               next_state <= CalcADDR;
            ELSIF (Opcode=op_not) THEN 
               next_state <= L_NOT;
            ELSIF ((Opcode = op_and) AND (bit5='0')) THEN 
               next_state <= And_R;
            ELSIF ((Opcode = op_and) AND (bit5='1')) THEN 
               next_state <= And_Imm;
            ELSIF (Opcode=op_JMP) THEN 
               next_state <= JMP;
            ELSIF (Opcode=op_LEA) THEN 
               next_state <= LEA;
            ELSIF ((Opcode = op_add) AND (bit5='0')) THEN 
               next_state <= ADD_R;
            ELSIF ((Opcode = op_add) AND (bit5='1')) THEN 
               next_state <= ADD_IM;
            ELSIF ((Opcode =op_jsr) AND (bit11='1')) THEN 
               next_state <= JSR1;
            ELSIF ((Opcode =op_jsr) AND (bit11='0')) THEN 
               next_state <= JSRR1;
            ELSIF (Opcode = op_trap) THEN 
               next_state <= TRAP1;
            ELSIF ((Opcode = op_ldi) OR ( Opcode = op_sti)) THEN 
               next_state <= CalcAddress;
            ELSIF (Opcode =op_shf) THEN 
               next_state <= SHF;
            ELSIF ((Opcode= op_ldb) OR (Opcode = op_stb)) THEN 
               next_state <= CalcAdd;
            ELSE
               next_state <= IF1;
            END IF;
         WHEN BR1 => 
            IF (((n AND CheckN) OR (p AND CheckP) OR (z AND CheckZ))='1') THEN 
               next_state <= BR2;
            ELSE
               next_state <= IF1;
            END IF;
         WHEN BR2 => 
            next_state <= IF1;
         WHEN L_NOT => 
            next_state <= IF1;
         WHEN IF1 => 
            next_state <= IF2;
         WHEN IF2 => 
            IF (MRESP_H='1') THEN 
               next_state <= IF3;
            ELSE
               next_state <= IF2;
            END IF;
         WHEN IF3 => 
            next_state <= Decode;
         WHEN CalcADDR => 
            IF (Opcode= op_str) THEN 
               next_state <= ST1;
            ELSIF (Opcode =op_ldr) THEN 
               next_state <= LD1;
            ELSE
               next_state <= CalcADDR;
            END IF;
         WHEN LD1 => 
            IF (MRESP_H ='1') THEN 
               next_state <= LD2;
            ELSE
               next_state <= LD1;
            END IF;
         WHEN ST1 => 
            next_state <= ST2;
         WHEN ST2 => 
            IF (MRESP_H='1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= ST2;
            END IF;
         WHEN LD2 => 
            next_state <= IF1;
         WHEN JMP => 
            next_state <= IF1;
         WHEN LEA => 
            next_state <= IF1;
         WHEN ADD_R => 
            next_state <= IF1;
         WHEN ADD_IM => 
            next_state <= IF1;
         WHEN And_R => 
            next_state <= IF1;
         WHEN And_Imm => 
            next_state <= IF1;
         WHEN JSR1 => 
            next_state <= IF1;
         WHEN JSRR1 => 
            next_state <= IF1;
         WHEN TRAP1 => 
            next_state <= Trap2_3;
         WHEN TRAP2 => 
            next_state <= IF1;
         WHEN Trap2_3 => 
            IF (MRESP_H ='1') THEN 
               next_state <= TRAP2;
            ELSE
               next_state <= Trap2_3;
            END IF;
         WHEN CalcAddress => 
            next_state <= CalcAddress2;
         WHEN CalcAddress2 => 
            IF (MRESP_H ='1') THEN 
               next_state <= CalcAddress3;
            ELSE
               next_state <= CalcAddress2;
            END IF;
         WHEN CalcAddress3 => 
            IF (Opcode = op_ldi) THEN 
               next_state <= LDI1;
            ELSIF (Opcode = op_sti) THEN 
               next_state <= STI1;
            ELSE
               next_state <= CalcAddress3;
            END IF;
         WHEN LDI1 => 
            IF (MRESP_H ='1') THEN 
               next_state <= LDI2;
            ELSE
               next_state <= LDI1;
            END IF;
         WHEN STI1 => 
            next_state <= STI2;
         WHEN STI2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= STI2;
            END IF;
         WHEN LDI2 => 
            next_state <= IF1;
         WHEN SHF => 
            next_state <= IF1;
         WHEN CalcAdd => 
            IF (Opcode = op_ldb) THEN 
               next_state <= EnterMDR;
            ELSIF (Opcode= op_stb) THEN 
               next_state <= STB0;
            ELSE
               next_state <= CalcAdd;
            END IF;
         WHEN STB0 => 
            IF (Parity ='1') THEN 
               next_state <= STB_1_1;
            ELSIF (Parity= '0') THEN 
               next_state <= STB_1_2;
            ELSE
               next_state <= STB0;
            END IF;
         WHEN EnterMDR => 
            IF (MRESP_H = '1') THEN 
               next_state <= Check4Byte;
            ELSE
               next_state <= EnterMDR;
            END IF;
         WHEN Check4Byte => 
            IF (Parity = '1') THEN 
               next_state <= HighB;
            ELSIF (Parity = '0') THEN 
               next_state <= LowB;
            ELSE
               next_state <= Check4Byte;
            END IF;
         WHEN HighB => 
            next_state <= IF1;
         WHEN LowB => 
            next_state <= IF1;
         WHEN STB_1_1 => 
            next_state <= MEM_HB;
         WHEN STB_1_2 => 
            next_state <= MEM_LB;
         WHEN MEM_LB => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= MEM_LB;
            END IF;
         WHEN MEM_HB => 
            IF (MRESP_H ='1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= MEM_HB;
            END IF;
         WHEN OTHERS =>
            next_state <= Reset;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : PROCESS ( 
      bit4,
      bit5,
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default Assignment
      ALUMuxSel <= "00";
      ALUop <= "000";
      DestnSel <= '1';
      LoadIR <= '0';
      LoadMAR <= '0';
      LoadMDR <= '0';
      LoadNZP <= '0';
      LoadPC <= '0';
      MARMuxSel <= "00";
      MDRMuxSel <= '0';
      MREAD_L <= '1';
      MWRITEH_L <= '1';
      MWRITEL_L <= '1';
      PCMuxSel <= "00";
      RFAorMDR <= '0';
      RFMuxSel <= "000";
      RegWrite <= '0';
      SextorADJ <= '0';
      ShiftSelector <= "00";
      StoreSR <= '1';

      -- Combined Actions
      CASE current_state IS
         WHEN BR2 => 
            PCMuxSel <="01";
            LoadPC <='1';
         WHEN L_NOT => 
            ALUop <= alu_not;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= "001";
         WHEN IF1 => 
            LoadMAR <= '1';
            LoadPC <= '1';
         WHEN IF2 => 
            LoadMDR <= '1';
            MREAD_L <='0' after 6ns;
         WHEN IF3 => 
            LoadIR <= '1';
         WHEN CalcADDR => 
            ALUMuxSel <= "01";
            ALUop <= alu_add;
            MARMuxSel <= "01";
            LoadMAR <= '1';
         WHEN LD1 => 
            LoadMDR <='1';
            MREAD_L <='0' after 6ns;
         WHEN ST1 => 
            StoreSR <= '0';
            ALUop <= alu_pass;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
         WHEN ST2 => 
            MWRITEL_L <= '0' after 6ns;
            MWRITEH_L  <= '0' after 6ns;
         WHEN LD2 => 
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN JMP => 
            LoadPC <= '1';
            PCMuxSel <="10";
         WHEN LEA => 
            RFMuxSel <= "010";
            RegWrite <= '1';
            LoadNZP <= '1';
            PCMuxSel <="00";
         WHEN ADD_R => 
            ALUop <=alu_add;
            RegWrite<='1';
            LoadNZP<='1';
            RFMuxSel<="001";
            ALUMuxSel<= "00";
         WHEN ADD_IM => 
            ALUop <= alu_add;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= "001";
            ALUMuxSel <= "10";
         WHEN And_R => 
            ALUop <= alu_and;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= "001";
            ALUMuxSel <= "00";
         WHEN And_Imm => 
            ALUop <= alu_and;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= "001";
            ALUMuxSel <="10";
         WHEN JSR1 => 
            RFMuxSel <= "011";
            DestnSel <= '0';
            RegWrite <= '1';
            PCMuxSel <= "11";
            LoadPC <= '1';
         WHEN JSRR1 => 
            RFMuxSel <= "011";
            DestnSel <= '0';
            RegWrite <= '1';
            PCMuxSel <= "10";
            LoadPC <= '1';
         WHEN TRAP1 => 
            RFMuxSel <= "011";
            DestnSel <= '0';
            RegWrite <= '1';
            MarMuxSel <= "10";
            LoadMAR <= '1';
         WHEN TRAP2 => 
            RFAorMDR <= '1';
            PCMuxSel <= "10";
            LoadPC <= '1';
         WHEN Trap2_3 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6ns;
         WHEN CalcAddress => 
            DestnSel <= '1';
            ALUMuxSel <= "01";
            ALUop <= alu_add;
            MARMuxSel <= "01";
            LoadMAR <= '1';
         WHEN CalcAddress2 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6ns;
         WHEN CalcAddress3 => 
            MARMuxSel <= "11";
            LoadMAR <= '1';
         WHEN LDI1 => 
            LoadMDR <= '1';
            RFMuxSel <= "000";
            MREAD_L<= '0' after 6ns;
         WHEN STI1 => 
            StoreSR <='0';
            ALUop <= alu_pass;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
         WHEN STI2 => 
            MWRITEL_L <= '0' after 6ns;
            MWRITEH_L <= '0' after 6ns;
         WHEN LDI2 => 
            RegWrite <= '1';
            LoadNZP <='1';
         WHEN SHF => 
            ShiftSelector <= bit4 & bit5;
            RFMuxSel <= "100";
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN CalcAdd => 
            SextorADJ <= '1';
            ALUMuxSel <="01";
            ALUop <= alu_add;
            MARMuxSel <= "01";
            LoadMAR <= '1';
         WHEN EnterMDR => 
            MDRMuxSel<= '0';
            LoadMDR <= '1';
            MREAD_L <= '0' after 6ns;
         WHEN HighB => 
            RFMuxSel <= "110";
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN LowB => 
            RFMuxSel <= "101";
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN STB_1_1 => 
            StoreSR <= '0';
            ALUMuxSel<= "11";
            ALUop <= alu_sll;
            MDRMuxSel <= '1';
            LoadMDR <= '1';
         WHEN STB_1_2 => 
            StoreSR <= '0';
            ALUop <= alu_pass;
            MDRMuxSel <= '1';
            LoadMDR <= '1';
         WHEN MEM_LB => 
            MWRITEH_L <= '1' after 6ns;
            MWRITEL_L <= '0' after 6ns;
         WHEN MEM_HB => 
            MWRITEH_L <= '0' after 6ns ;
            MWRITEL_L <= '1' after 6ns;
         WHEN OTHERS =>
            NULL;
      END CASE;
   END PROCESS output_proc;
 
END fsm;
